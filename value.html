<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Value Bets</title>
  <style>
    body { background: #1e1e2f; color: #fff; font-family: 'Segoe UI', sans-serif; padding: 2rem; }
    h1 { color: #ffd700; text-align: center; margin-bottom: 1rem; }
    h2 { color: #ffd700; margin-top: 2.5rem; border-bottom: 2px solid #444; padding-bottom: 0.3rem; }
    .nav-link { text-align: center; margin-bottom: 2rem; }
    .nav-link a { color: #00bfff; text-decoration: none; font-weight: bold; font-size: 1.1rem; }
    .nav-link a:hover { text-decoration: underline; }
    table {
      width: 100%;
      border-collapse: collapse;
      background: #2c2c3e;
      border-radius: 8px;
      overflow: hidden;
      margin-bottom: 2rem;
    }
    th, td { padding: 0.6rem 1rem; text-align: center; vertical-align: top; }
    th { background: #444; color: #ffd700; }
    tr:nth-child(even) { background: #2a2a3d; }

    tr.multi-tag-row  { background: #37be5e !important; color: #1b2b1a !important; font-weight: bold; border-left: 8px solid #26c738; border-bottom: 4px solid #111; }
    tr.aibest-row     { background: #0f3057 !important; color: #ffffff; font-weight: bold; border-left: 8px solid #00d9ff; }
    tr.rawlay-row     { background: #6d0e0e !important; color: #fff2f2; font-weight: bold; border-left: 8px solid #ff4c4c; }
    tr.rawvalue-row   { background: #555 !important; color: #fff5d7; font-weight: bold; border-left: 8px solid #c2e7ff; }
    tr.tonywatch-row  { background: #ffe6a7 !important; color: #2a2a2a; font-weight: bold; border-left: 8px solid #ffa500; }
    tr.sleeper-row    { background: #3e235e !important; color: #e0aaff; font-weight: bold; }
    tr.value-row      { background: #ffd700 !important; color: #222; font-weight: bold; }
    tr.blue-row       { background: #1f3b70 !important; color: #a8d1ff; font-weight: bold; border-left: 8px solid #00bfff; }
    tr.toprated-row   { background: #262629 !important; color: #ffe066; font-weight: bold; border-left: 8px solid #ffe066; }

    /* rank overlay highlight */
    tr.overlay-row    { background: #0b3d2e !important; color: #c2ffd7; font-weight: bold; border-left: 8px solid #2ee59d; }

    /* FC/TC highlight rows */
    tr.fc-row         { background: #23364d !important; color: #d5e9ff; font-weight: bold; border-left: 8px solid #00bfff; }
    tr.tc-row         { background: #2d213a !important; color: #f1d7ff; font-weight: bold; border-left: 8px solid #be7bff; }

    small.reason { display: block; font-weight: bold; font-size: 0.85em; margin-top: 0.3em; }
    tr.multi-tag-row small.reason, tr.value-row small.reason { color: #000; }
    tr.aibest-row small.reason { color: #fff; }

    /* Extra Places badge */
    .ep-badge {
      display: inline-block;
      margin-left: 6px;
      padding: 0.05rem 0.4rem;
      border-radius: 5px;
      background: #111;
      border: 1px solid #2ee59d;
      color: #2ee59d;
      font-weight: 700;
      font-size: 0.8rem;
      line-height: 1.2;
    }
  </style>
</head>
<body>
  <h1>🔥 Automated Best Bet Selections 🔥</h1>
  <div class="nav-link">
    <a href="index.html">🔙 Back to Race Visualizer</a>
  </div>

  <h2>🟩➕ Big Priced E/W - Extra Places</h2>
  <table id="multitag-table"><thead><tr><th>Race</th><th>Horse</th><th>Odds</th><th>Tags</th></tr></thead><tbody></tbody></table>

  <h2>❌ Must Lay</h2>
  <table id="rawlays-table"><thead><tr><th>Race</th><th>Horse</th><th>Odds</th><th>Tags</th></tr></thead><tbody></tbody></table>

  <!-- FC/TC sections -->
  <h2>🔗 Forecasts (Top 2 clear)</h2>
  <table id="fc-table">
    <thead>
      <tr><th>Race</th><th>Combo</th><th>Why</th></tr>
    </thead>
    <tbody></tbody>
  </table>

  <h2>🔗 Tricasts (Top 3 clear)</h2>
  <table id="tc-table">
    <thead>
      <tr><th>Race</th><th>Combo</th><th>Why</th></tr>
    </thead>
    <tbody></tbody>
  </table>
  <!-- END FC/TC -->

  <h2>🤖 AI Suggested Bets</h2>
  <table id="aibets-table"><thead><tr><th>Race</th><th>Horse</th><th>Odds</th><th>AI Tag</th><th>Reason</th></tr></thead><tbody></tbody></table>

  <h2>📉 Raw Value</h2>
  <table id="rawvalue-table"><thead><tr><th>Race</th><th>Horse</th><th>Odds</th><th>Tags</th></tr></thead><tbody></tbody></table>

  <h2>👀 Tony Watch</h2>
  <table id="tonywatch-table"><thead><tr><th>Race</th><th>Horse</th><th>Odds</th><th>Tags</th></tr></thead><tbody></tbody></table>

  <h2>🌑 Sleepers</h2>
  <table id="sleepers-table"><thead><tr><th>Race</th><th>Horse</th><th>Odds</th><th>Tags</th></tr></thead><tbody></tbody></table>

  <h2>💰 Model Value</h2>
  <table id="value-table"><thead><tr><th>Race</th><th>Horse</th><th>Odds</th><th>Tags</th></tr></thead><tbody></tbody></table>

  <!-- Rank Overlays section -->
  <h2>📊 Rank Overlays (Model ≪ Market)</h2>
  <table id="overlay-table">
    <thead>
      <tr>
        <th>Race</th>
        <th>Horse</th>
        <th>Odds</th>
        <th>Δ (Market − Model)</th>
        <th>Ranks (Mdl / Mkt)</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>

  <h2>🔵 Big E/W Odds</h2>
  <table id="blue-table"><thead><tr><th>Race</th><th>Horse</th><th>Odds</th><th>Tags</th></tr></thead><tbody></tbody></table>

  <h2>🥇 Top Rated Clear</h2>
  <table id="toprated-table"><thead><tr><th>Race</th><th>Horse</th><th>Odds</th><th>Tags</th></tr></thead><tbody></tbody></table>

<script>
(async () => {
  // --- Helpers
  const safeJSON = async (url) => {
    try {
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(r.statusText);
      return await r.json();
    } catch (e) {
      console.warn(`⚠️ Could not load ${url}:`, e.message || e);
      return []; // graceful fallback
    }
  };

  const safeText = async (url) => {
    try {
      const r = await fetch(url, { cache: 'no-store' });
      if (!r.ok) throw new Error(r.statusText);
      return await r.text();
    } catch (e) {
      console.warn(`⚠️ Could not load ${url}:`, e.message || e);
      return "";
    }
  };

  const timeFromRaceDT = (raceDT) => {
    if (!raceDT || typeof raceDT !== 'string') return '';
    const parts = raceDT.split(' ');
    return parts.length > 1 ? parts[1] : raceDT;
  };

  const parseRaceDT = (raceDT) => {
    // expects "DD/MM/YYYY HH:MM"
    try {
      const [d, t='00:00'] = (raceDT || '').split(' ');
      const [day, month, year] = d.split('/').map(Number);
      const [hh=0, mm=0] = t.split(':').map(Number);
      return new Date(year, (month || 1) - 1, day || 1, hh, mm);
    } catch {
      return new Date(0);
    }
  };

  // normalize key so course matching is case-insensitive + trimmed
  const normCourse = s => (s || "").toString().trim().toLowerCase();
  const normDT     = s => (s || "").toString().trim();
  const raceKey    = (dt, course) => `${normDT(dt)}_${normCourse(course)}`;

  // --- Load Extra Places (JSON Lines) ---
  // File: extra_places.txt (one JSON object per line)
  // Example line: {"race_datetime":"27/10/2025 16:20","course":"Redcar","places":4}
  const loadExtraPlaces = async (url) => {
    const txt = await safeText(url);
    const lines = (txt || "").split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    const map = new Map();
    for (const line of lines) {
      try {
        const obj = JSON.parse(line);
        const dt = String(obj.race_datetime || "");
        const course = String(obj.course || "");
        const places = Number(obj.places || obj.ew_places || 0);
        if (dt && course && places > 0) {
          map.set(raceKey(dt, course), places);
        }
      } catch (e) {
        console.warn("⚠️ Bad JSON line in extra_places.txt:", line);
      }
    }
    return map;
  };

  const extraPlaces = await loadExtraPlaces('extra_places.txt');

  const getPlaces = (entry) => extraPlaces.get(raceKey(entry.race_datetime, entry.course));
  const isExtraPlaceRace = (entry) => extraPlaces.has(raceKey(entry.race_datetime, entry.course));

  // --- Load data (robust)
  const valueData = await safeJSON('value_bets.json');
  let aiData = await safeJSON('ai_bets.json'); // let so we can filter it

  // --- Quality filter: require BOTH >= 90
  const filterValid = (entry) => {
    const coverage   = Number(entry?.data_coverage ?? 100);
    const confidence = Number(entry?.race_data_confidence ?? 100);
    return (coverage >= 90 && confidence >= 90);
  };

  // Map for quick lookup when enriching AI rows with bookie/raw odds
  const valueMap = new Map(
    valueData.map(e => [raceKey(e.race_datetime, e.course) + "_" + e.horse, e])
  );

  // Merge (dedupe by race_datetime+course+horse), union tags, prefer latest reason
  const merged = new Map();
  [...valueData, ...aiData].forEach(e => {
    const key = raceKey(e.race_datetime, e.course) + "_" + e.horse;
    const existing = merged.get(key) || {};
    const existingTags = Array.isArray(existing.tags) ? existing.tags : [];
    const newTags = Array.isArray(e.tags) ? e.tags : [];
    const tags = Array.from(new Set([...existingTags, ...newTags]));
    merged.set(key, { ...existing, ...e, tags, reason: e.reason || existing.reason || "" });
  });

  // Filter & sort by race time within the day
  const entries = Array.from(merged.values())
    .filter(filterValid)
    .sort((a,b) => timeFromRaceDT(a.race_datetime).localeCompare(timeFromRaceDT(b.race_datetime)));

  const tagSet = (entry) =>
    Array.isArray(entry.tags) ? [...new Set(entry.tags.map(t => String(t).toLowerCase()))] : [];

  const iconsOnly = (tags) => tags.map(t =>
      t === 'top-rated-clear' ? '🥇' :
      t === 'sleeper'         ? '🌑' :
      t === 'value'           ? '💰' :
      t === 'blue'            ? '🔵' :
      t === 'tony-watch'      ? '👀' :
      t === 'raw-value'       ? '📉' :
      t === 'raw-lay'         ? '❌' :
      t === 'ai-back'         ? '🟢' :
      t === 'ai-lay'          ? '❌'  :
      t === 'rank-overlay'    ? '📊'  : ''
  ).join(' ');

  const twoLineRow = (entry, tagList, rowClass = "") => {
    const reason = entry.reason ? `<small class='reason'>🧠 ${entry.reason}</small>` : "";
    const bookie = entry.bookie_odds ?? "-";
    const raw = entry.raw_odds ?? "-";
    const tags = iconsOnly(tagList);

    // show EP×N badge next to course
    const ep = getPlaces(entry);
    const courseHtml = ep ? `${entry.course ?? ""} <span class="ep-badge">EP×${ep}</span>`
                          : `${entry.course ?? ""}`;

    return `<tr${rowClass ? ` class="${rowClass}"` : ""}>
      <td><div>${timeFromRaceDT(entry.race_datetime)}</div><div>${courseHtml}</div></td>
      <td><div>${entry.horse ?? ""}</div>${reason}</td>
      <td><div>${bookie}</div><div>${raw}</div></td>
      <td><div>${tags}</div></td>
    </tr>`;
  };

  // compact renderer for Rank Overlays table
  const overlayRow = (entry, tagList, rowClass = "") => {
    const reason = entry.reason ? `<small class='reason'>🧠 ${entry.reason}</small>` : "";
    const bookie = entry.bookie_odds ?? "-";
    const raw    = entry.raw_odds ?? "-";
    const delta  = (entry.rank_delta ?? "");
    const rModel = (entry.rank_model ?? "");
    const rMarket= (entry.rank_market ?? "");
    const ep = getPlaces(entry);
    const courseHtml = ep ? `${entry.course ?? ""} <span class="ep-badge">EP×${ep}</span>`
                          : `${entry.course ?? ""}`;

    return `<tr${rowClass ? ` class="${rowClass}"` : ""}>
      <td><div>${timeFromRaceDT(entry.race_datetime)}</div><div>${courseHtml}</div></td>
      <td><div>${entry.horse ?? ""}</div>${reason}</td>
      <td><div>${bookie}</div><div>${raw}</div></td>
      <td><strong>${delta}</strong></td>
      <td>${rModel || ""} / ${rMarket || ""}</td>
    </tr>`;
  };

  const renderAITag = (tag) => tag === 'ai-back' ? '🟢 Back' : tag === 'ai-lay' ? '❌ Lay' : '';

  // --- Build buckets
  let multi='', aihtml='', rawlays='', rawv='', tony='', sleepers='', value='', blue='', top='', overlay='';

  entries.forEach(entry => {
    const tags = tagSet(entry);

    // treat overlay+N tags as decorative, but DO count rank-overlay
    const isOverlayTag = t => t.startsWith("overlay+");
    const coreTags = tags.filter(t => !isOverlayTag(t));

    // "Big Priced E/W - Extra Places" = multi-tag rows, ONLY IF race is an extra-places race
    if (coreTags.length > 1 && isExtraPlaceRace(entry)) {
      multi += twoLineRow(entry, tags, "multi-tag-row");
    }

    if (tags.includes("raw-lay"))       rawlays  += twoLineRow(entry, tags, "rawlay-row");
    if (tags.includes("raw-value"))     rawv     += twoLineRow(entry, tags, "rawvalue-row");
    if (tags.includes("tony-watch"))    tony     += twoLineRow(entry, tags, "tonywatch-row");
    if (tags.includes("sleeper"))       sleepers += twoLineRow(entry, tags, "sleeper-row");
    if (tags.includes("value"))         value    += twoLineRow(entry, tags, "value-row");
    if (tags.includes("blue"))          blue     += twoLineRow(entry, tags, "blue-row");
    if (tags.includes("top-rated-clear")) top    += twoLineRow(entry, tags, "toprated-row");
  });

  // --- Rank Overlays: biggest Δ first
  const overlayEntries = entries
    .filter(e => tagSet(e).includes("rank-overlay"))
    .sort((a,b) => Number(b.rank_delta || 0) - Number(a.rank_delta || 0));

  overlayEntries.forEach(e => {
    overlay += overlayRow(e, tagSet(e), "overlay-row");
  });

  // --- Forecasts / Tricasts from value_bets.json combos (use raw valueData, not merged)
  const byRaceTime = (a, b) => parseRaceDT(a.race_datetime) - parseRaceDT(b.race_datetime);
  const asComboLabel = (e) => Array.isArray(e.combo) && e.combo.length ? e.combo.join(" » ") : (e.horse || "");

  const fcEntries = valueData
    .filter(filterValid)
    .filter(e => Array.isArray(e.tags) && e.tags.includes('forecast'))
    .sort(byRaceTime);

  const tcEntries = valueData
    .filter(filterValid)
    .filter(e => Array.isArray(e.tags) && e.tags.includes('tricast'))
    .sort(byRaceTime);

  let fcHtml = '', tcHtml = '';
  fcEntries.forEach(e => {
    const ep = extraPlaces.get(raceKey(e.race_datetime, e.course));
    const courseHtml = ep ? `${e.course ?? ""} <span class="ep-badge">EP×${ep}</span>` : `${e.course ?? ""}`;
    fcHtml += `<tr class="fc-row">
      <td><div>${timeFromRaceDT(e.race_datetime)}</div><div>${courseHtml}</div></td>
      <td><b>${asComboLabel(e)}</b></td>
      <td><small class="reason">${e.reason ?? ""}</small></td>
    </tr>`;
  });

  tcEntries.forEach(e => {
    const ep = extraPlaces.get(raceKey(e.race_datetime, e.course));
    const courseHtml = ep ? `${e.course ?? ""} <span class="ep-badge">EP×${ep}</span>` : `${e.course ?? ""}`;
    tcHtml += `<tr class="tc-row">
      <td><div>${timeFromRaceDT(e.race_datetime)}</div><div>${courseHtml}</div></td>
      <td><b>${asComboLabel(e)}</b></td>
      <td><small class="reason">${e.reason ?? ""}</small></td>
    </tr>`;
  });

  // --- AI list (independent render, enriched, and filtered)
  aiData = aiData.filter(filterValid)
                 .sort((a,b) => parseRaceDT(a.race_datetime) - parseRaceDT(b.race_datetime));

  aiData.forEach(e => {
    const key = raceKey(e.race_datetime, e.course) + "_" + e.horse;
    const aiTag = (e.tags || []).find(t => t === 'ai-back' || t === 'ai-lay');
    if (!aiTag) return;

    const valueEntry = valueMap.get(key);
    const bookie = (valueEntry?.bookie_odds ?? e.bookie_odds) ?? "-";
    const raw    = (valueEntry?.raw_odds    ?? e.raw_odds)    ?? "-";
    const reason = e.reason || "";
    const ep = extraPlaces.get(raceKey(e.race_datetime, e.course));
    const courseHtml = ep ? `${e.course ?? ""} <span class="ep-badge">EP×${ep}</span>` : `${e.course ?? ""}`;

    aihtml += `<tr class="aibest-row">
      <td><div>${timeFromRaceDT(e.race_datetime)}</div><div>${courseHtml}</div></td>
      <td>${e.horse ?? ""}</td>
      <td><div>${bookie}</div><div>${raw}</div></td>
      <td>${renderAITag(aiTag)}</td>
      <td><small class="reason">🧠 ${reason}</small></td>
    </tr>`;
  });

  // --- Write tables
  const setBody = (sel, html, cols=4) => {
    const el = document.querySelector(sel + ' tbody');
    el.innerHTML = html || `<tr><td colspan="${cols}">No entries found.</td></tr>`;
  };

  setBody('#multitag-table',  multi);
  setBody('#rawlays-table',   rawlays);

  // FC/TC render
  setBody('#fc-table',        fcHtml, 3);
  setBody('#tc-table',        tcHtml, 3);

  setBody('#aibets-table',    aihtml, 5);
  setBody('#rawvalue-table',  rawv);
  setBody('#tonywatch-table', tony);
  setBody('#sleepers-table',  sleepers);
  setBody('#value-table',     value);
  setBody('#overlay-table',   overlay, 5);
  setBody('#blue-table',      blue);
  setBody('#toprated-table',  top);
})();
</script>
</body>
</html>

